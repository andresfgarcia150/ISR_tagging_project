% !TeX spellcheck = en_US
\documentclass[12pt, oneside]{book}              % Book class in 11 points
\usepackage{amsmath, amsthm, amssymb}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{cancel}
\usepackage{graphicx}
\usepackage{hyperref}% add hypertext capabilities
\setlength{\parskip}{4mm}

% For several graphics per figure
\usepackage{caption} %[caption=false]
\usepackage{subfigure}

% For centering elements in tables
\usepackage{array}

% For multirows and multicolumns in tables
\usepackage{multicol}
\usepackage{multirow}

% Epigraph
\usepackage{epigraph}

% List package (useful to write codes)
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mygray2}{rgb}{0.9,0.9,0.9}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\usepackage{listings}
\lstset{
basicstyle=\small\tt,
breaklines=true,
commentstyle=\color{mygreen}\small,
keywordstyle=\color{blue}\small,
stringstyle=\color{mymauve}\small,
numbers=left,
numberstyle=\small\color{mygray},
backgroundcolor=\color{mygray2}
}

% Appendix
\usepackage[toc,page]{appendix}


%\oddsidemargin 0.4cm \evensidemargin 0.4cm \topmargin 0.0cm
%\textwidth 15.7cm \textheight 22.0cm \headsep 1.2cm \footskip 1.0cm

\title{\bf Documentation of the project: \\ ISR jet tagging}
\author{\textbf{Author:}\\ Andr\'es Felipe Garc\'ia Albarrac\'in \\ \\ \textbf{Advisor:} \\ Juan Carlos Sanabria, Ph.D.}
\date{\today}

\begin{document}                        % End of preamble, start of text.
	\frontmatter                            % only in book class (roman page #s)
	\maketitle                              % Print title page.
	\tableofcontents                        % Print table of contents
	\mainmatter                             % only in book class (arabic page #s)

\chapter{Introduction}

During the last semester of 2014, I made my Undergraduate Thesis Project entitled 
``\textit{Design of algorithms to identify high momentum Initial State Radiation 
(ISR) Jets in proton â€“ proton collision events}'', under the supervision of Juan
Carlos Sanabria, Ph.D.. As the name suggests, the project consisted in the proposal
of an algorithm to identify ISR jets. Due to the promising results, I was employed 
during the first semester of 2015 under the charge ``Joven Investigador'' of 
COLCIENCIAS in order to improve the initially obtained results. Throughout this
time, several codes and programs were developed. To encourage the continuation of
this project, this report has been written with a summary of all the technical 
work done so far.

In practical matters, one of the main drawbacks of Quantum Field Theory (QFD) is 
the inherent difficulty of its calculations. Feynman diagrams are not easy to solve
and specially when high orders are involved. Consequently, the usage of algorithms
and computer simulations have played an important role in the prediction of 
numerical results thanks to the great calculation power of modern computers. Several
programs have been written with this purpose and today there exists a machinery
which combines QFD, statistical models and Monte Carlo methods to reproduce High
Energy Physics experiments.

In this project, three of those programs were used: 
MadGraph 5.2 (MadEvent)~\cite{Alwall:2014hca}, Pythia 8.2~\cite{Sjostrand:2014zea} 
~\cite{Sjostrand:2006za} and Delphes 3.2~\cite{deFavereau:2013fsa} with the aim of 
simulating proton - proton collision events. The description of those programs and
their particular purposes in the project are described in chapter 
\ref{cha:Simulation_chain}. In addition, chapter \ref{cha:Simulation_chain}
includes the explanation of the codes and the scripts that were developed
both to integrate those programs, and to run the simulations under specific conditions.

In despite of the fact that those simulations demanded a huge amount of computational
time, they just served as inputs of the algorithms written throughout the project,
which contain the main proposed analysis and ideas. Altogether, four algorithms
were elaborated. Each of them are explained in chapter 3, where their documentation
and an overall description are presented. 

Finally, chapter four includes a brief description of some software tools that
were introduced to the project. Specifically, this project used C++ codes which
included root libraries instead of root macros. This transition reduced the 
execution time of the algorithms six times. Additionally, the development 
environment \emph{Eclipse} was also introduced, which made easier the programming
process. Overall, these tools dramatically improved the technical work of the project.

\chapter{Simulation chain} \label{cha:Simulation_chain}

\epigraph{\textquotedblleft \textit{Divide et impera}\textquotedblright, \\ \textquotedblleft
Divide and conquer\textquotedblright}{Philip II of Macedon}

At first glance, it is not clear why it is necessary to use three programs at the
simulation stage instead of just one. The answer is quite simple: each one of those
programs has been developed to run a specific task in the simulation process, and 
therefore, each one has been optimized to do so as accurate and fast as possible. 
While MadGraph and Pythia are responsible for the simulation of high energy collision's 
Physics, Delphes takes the final state particles produced by the former programs, and
determines what would be the corresponding response of a detector. This scheme is
useful as it maintains the detector apart from the main calculations of the simulation.
Additionally, it makes the change of experiment parameters as simple as modifying
Delphes execution specifications.

As presented before, MadGraph and Pythia handle the Physics of the collision. Again,
there is more than a single program for this task, and now the reason to use two programs lies on the
limits of the theoretical models. At the very first moment of the collision when
the Energy Density of the System is high enough, perturbative Quantum Chromo-Dynamics
(pQCD), Quantum Electro-Dynamics (QED) and ElectroWeak Theory are the most accurate models
known so far. MadGraph, and specifically MadEvent, use them to calculate the transverse
sections of a particular channel defined by the user. From this calculation and the Monte 
Carlo models, it randomly establishes the kinematic variables of the resulting particles
of the collision.

Once the energy density of the collision has been reduced significantly, the models used
by MadGraph are not valid, and then Pythia appears in the scene. The particles resulting
from MadGraph are taken by Pythia, which makes the evolution to a multi-hadronic final
state ~\cite{Sjostrand:2014zea}. The task run by Pythia involves the usage of Monte
Carlo techniques to simulate hadronization, decays and showers. Finally, the particles
obtained at the end of the Pythia simulation are the inputs for the Delphes simulation.

Although the usage of several programs for the simulation means better results, it also
implies the challenge of connecting them. This task has already been done inside the MadGraph
package, which connects MadEvent + Pythia 6 + Delphes / PGS\footnote{\textit{Pretty 
Good Simulation}, PGS, is another program for detector simulation}. However, the version
of Pythia included there (v.6) is old and does not offer the possibility of controlling 
ISR emissions as the last one (v.8) does. As ISR emissions were the main focus of the 
project, it was convenient to use Pythia 8 instead of Pythia 6 and therefore to develop
the integration of MadGraph 5.2 with Pythia 8.2 and Delphes 3.2.

Throughout this chapter, the codes and scripts written to achieve the simulation will
be explained. One section is devoted to each program and another one presents the
script that connects the three programs. Finally, the last section of this chapter
presents the procedure known as Matching between MadGraph and Pythia, which ensures that
the physics calculations made by each program correspond to the Energy scale that
each one of them should handle.

\section{Usage of MadGraph 5.2} \label{sec:MadGraph}

The most basic procedure to simulate collision events using MadGraph is by means of its
executable program. Follow the next steps to run a set of simulations of the channel
$ p\ p\ \to t\ \tilde{t} $. It is important that MadGraph has been correctly installed
\footnote{A full set of instructions to install MadGraph and other High Energy Physics
programs can be found at \url{http://goo.gl/vigBdj}}.

\begin{enumerate}
\item In the folder where MadGraph has been installed, type:  
\\ \texttt{./bin/mg5\_aMC}
\item Once MadGraph has been initialized, import the Standard Model parameters:
\\ \texttt{import model sm}
\item Generate the event $ p\ p\ \to t\ \tilde{t} $:
\\ \texttt{generate p p > t t$ \sim $}
\item Create an output folder where all the simulation files will be saved, in this case
test\_t\_tbar:
\\ \texttt{output test\_t\_tbar} 
\item Launch the Feynman diagrams production:
\\ \texttt{launch -m}
\\ and select the number of cores you want to use for the simulation
\item Turn off Pythia and other programs\footnote{This project uses the last version 
of Pythia (8.2) instead of the sixth version that uses MadGraph}. You can switch 
off and on by typing the number before the program (type 1 to toggle pythia, for instance).
Then, press enter.
\item Modify the \texttt{run\_card.dat} file by typing 2. Write \texttt{:32} and press
enter to go to line 32, then type \texttt{i} and press enter to modify the file. Change
the number of events from 10000 to 1000. Press \texttt{Esc} and write \texttt{:wq} to
write and quit.
\item Press enter to run the simulation

\end{enumerate}

Although simple, the latter approach is not the best as it requires the user interaction
several times to configure the simulation, which is not desirable when more than a single 
simulation will be performed. In such situations, all the configuration parameters
can be defined trough an input file. For the previous example, the input file would be:

\noindent \texttt{import model sm
\\generate p p > t t\~
\\output test\_t\_tbar -f
\\launch -m
\\2
\\pythia=OFF
\\Template/LO/Cards/run\_card.dat
\\models/sm\_v4/param\_card.dat}

\noindent where 2 corresponds to the number of cores used in the simulation, 
\texttt{run\_card.dat} is the default file of MadGraph and \texttt{param\_card.dat} 
contains the Standard Model parameters and values. Here, these two files correspond
to the default ones that MadGraph provide. In order to use another set of 
configuration parameters, the files should be copied to another location
and modified according to desired simulation conditions.

The input file may be saved as \texttt{mg5\_input.mg5} and the simulation can be
executed as:

\noindent \texttt{./bin/mg5\_aMC -f mg5\_input.mg5} \footnote{Observe that it is
supposed that \texttt{mg5\_input.mg5} is localed at the MadGraph folder and that
the command is run from the same directory. If not, the execution instruction and
the input file should contain the full path accordingly.}

As a result of the simulation by MadGraph, the output folder contains several 
folders with all the information related to the simulation. The folder 
\texttt{Cards} for instance, contains some parameter cards used in the simulation,
while the folder \texttt{HTML}, and specially the file \texttt{info.html} present
the Feynman diagrams created by MadGraph. The events resulting from the simulation
are found in the folder \texttt{Events/run\_01} in the form of two files: a root 
file called \texttt{unweighted\_events.root} and a compressed Les Houches Event file
with name \texttt{unweighted\_events.lhe}.

\section{Usage of Pythia 8.2} \label{sec:Pythia8}

The simulation carried out by MadGraph is now passed to Pythia, which takes the
file \texttt{unweighted\_events.lhe} as input. Pythia uses the information 
contained in such file to develop the hadronization, and produces another file
with the kinematic variables of the resulting particles. The task performed by
Pythia can be summarized in the Black Box of Fig. \ref{fig:Black_box_pythia}, 
where in addition to the file produced by MadGraph, a plain text file with 
extension \texttt{.cmnd} is passed by parameter to configure the simulation.

\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{Imags_Doc/Black_box_pythia}
\caption{}
\label{fig:Black_box_pythia}
\end{figure}

The functionality of the black box of \ref{fig:Black_box_pythia} is done by
a program written in C++, which is based on the examples provided by Pythia 
developers ~\cite{Sjostrand:2006za}. The code is called \texttt{hadronization02.cc}, 
was written in C++ and can be found at Appendix \ref{App:hadronization02.cc}.
It performs specific requirements for this project that will be mentioned soon. 
Before presenting the operations performed by the program, it is convenient 
to describe how this code should be compiled and used. 

\subsection{Code Usage}\label{sub:Code_usage}

To use \texttt{hadronization02.cc}, it is necessary to have installed 
Pythia\footnote{Again, information to install Pythia 8.2 and HepMC can be 
found at \url{http://goo.gl/vigBdj}} and StdHep\footnote{StdHep can be 
downloaded from \url{http://cepa.fnal.gov/psm/stdhep/getStdHep.shtml}.
It is enough to type \texttt{make} to install it}~\cite{Garren-StdHep}.
Once installed, go to the \texttt{examples} folder located at the Pythia
directory \footnote{If \texttt{examples} is not exactly there, it may 
be in \texttt{share/Pythia8}}.
Inside such folder, copy the code \texttt{hadronization02.cc} and then 
modify the \texttt{Makefile} in order to compile it. It is enough to insert
the following lines at the beginning of the \texttt{Makefile}:

\lstinputlisting[language=make]{Make_first_part}

\noindent changing \texttt{<STDHEP Directory>} in line 2 by the local
installation directory of StdHep. Furthermore, these other lines should
be included at the end of the \texttt{Makefile}:

\lstinputlisting[language=make]{Make_second_part}

After doing so, the code is compiled by typing on terminal:

\texttt{make hadronization02}

As a result, the executable file \texttt{hadronization02} is created in 
the current folder. It may be copied and used in other directory.
The instruction to run this program is:

\texttt{./hadronization02 input.cmnd [output.hep]}

\noindent where \texttt{input.cmnd} is the full name (with the path) of 
the configuration file, and \texttt{output.hep} is an optional parameter
that corresponds to the name of the output file.

Continuing with the $ t\ \tilde{t} $ production example of the previous
section, the following file may be saved as \texttt{input.cmnd} and
used as input of the Pythia simulation:

\lstinputlisting{input_pythia.cmnd}

Each line of this file is a different command which is described after
the exclamation mark character \textquoteleft!'. As it can be seen, 1000 
events are hadronized, the file \texttt{unweighted\_events.lhe} from 
MadGraph is read, and only ISR emissions are allowed.


\subsection{The code}\label{sub:Pythia_code}

. Overall, the code can be described
in three steps:

\begin{enumerate}
\item \textbf{Input file:} 
\\Pythia is configured by means of an input file that the user needs
 to specify when executing the code. It is a plain text file with extension
\texttt{.cmnd} and contains parameters for the Pythia execution, such as the
\texttt{.lhe} file produced by MadGraph and the hadronization conditions. 
An example of this file is:



\item  \textbf{Hadronization  and Veto ISR}

\item \textbf{Output}

\end{enumerate}

 The code can be compiled using the \texttt{Makefile} available at the folder
examples. It is necessary to have installed Pythia including a HepMC package 
\footnote{Again, information to install Pythia 8.2 and HepMC can be found at
\url{http://goo.gl/vigBdj}}. Additionally, the \texttt{Makefile}

\begin{appendices}
\chapter[Pythia code]{Pythia code: hadronization02.cc}\label{App:hadronization02.cc}
\lstinputlisting[language=C++]{hadronization02.cc}
\end{appendices}


\bibliographystyle{unsrt}

\bibliography{My_Bibliography_report}
	

\end{document}
