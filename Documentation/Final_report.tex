% !TeX spellcheck = es_CO
\documentclass[12pt, oneside]{book}              % Book class in 11 points
\usepackage{amsmath, amsthm, amssymb}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{cancel}
\usepackage{graphicx}
\usepackage{hyperref}% add hypertext capabilities
\setlength{\parskip}{4mm}

% For several graphics per figure
\usepackage{caption} %[caption=false]
\usepackage{subfigure}

% For centering elements in tables
\usepackage{array}

% For multirows and multicolumns in tables
\usepackage{multicol}
\usepackage{multirow}

% Epigraph
\usepackage{epigraph}

% List package (useful to write codes)
\usepackage{listings}

%\oddsidemargin 0.4cm \evensidemargin 0.4cm \topmargin 0.0cm
%\textwidth 15.7cm \textheight 22.0cm \headsep 1.2cm \footskip 1.0cm

\title{\bf Documentation of the project: \\ ISR jet tagging}
\author{\textbf{Author:}\\ Andr\'es Felipe Garc\'ia Albarrac\'in \\ \\ \textbf{Advisor:} \\ Juan Carlos Sanabria, Ph.D.}
\date{\today}

\begin{document}                        % End of preamble, start of text.
	\frontmatter                            % only in book class (roman page #s)
	\maketitle                              % Print title page.
	\tableofcontents                        % Print table of contents
	\mainmatter                             % only in book class (arabic page #s)

\chapter{Introduction}

During the last semester of 2014, I made my Undergraduate Thesis Project entitled 
``\textit{Design of algorithms to identify high momentum Initial State Radiation 
(ISR) Jets in proton â€“ proton collision events}'', under the supervision of Juan
Carlos Sanabria, Ph.D.. As the name suggests, the project consisted in the proposal
of an algorithm to identify ISR jets. Due to the promising results, I was employed 
during the first semester of 2015 under the charge ``Joven Investigador'' of 
COLCIENCIAS in order to improve the initially obtained results. Throughout this
time, several codes and programs were developed. To encourage the continuation of
this project, this report has been written with a summary of all the technical 
work done so far.

In practical matters, one of the main drawbacks of Quantum Field Theory (QFD) is 
the inherent difficulty of its calculations. Feynman diagrams are not easy to solve
and specially when high orders are involved. Consequently, the usage of algorithms
and computer simulations have played an important role in the prediction of 
numerical results thanks to the great calculation power of modern computers. Several
programs have been written with this purpose and today there exists a machinery
which combines QFD, statistical models and Monte Carlo methods to reproduce High
Energy Physics experiments.

In this project, three of those programs were used: 
MadGraph 5.2 (MadEvent)~\cite{Alwall:2014hca}, Pythia 8.2~\cite{Sjostrand:2014zea} 
~\cite{Sjostrand:2006za} and Delphes 3.2~\cite{deFavereau:2013fsa} with the aim of 
simulating proton - proton collision events. The description of those programs and
their particular purposes in the project are described in chapter 
\ref{cha:Simulation_chain}. In addition, chapter \ref{cha:Simulation_chain}
includes the explanation of the codes and the scripts that were developed
both to integrate those programs, and to run the simulations under specific conditions.

In despite of the fact that those simulations demanded a huge amount of computational
time, they just served as inputs of the algorithms written throughout the project,
which contain the main proposed analysis and ideas. Altogether, four algorithms
were elaborated. Each of them are explained in chapter 3, where their documentation
and an overall description are presented. 

Finally, chapter four includes a brief description of some software tools that
were introduced to the project. Specifically, this project used C++ codes which
included root libraries instead of root macros. This transition reduced the 
execution time of the algorithms six times. Additionally, the development 
environment \emph{Eclipse} was also introduced, which made easier the programming
process. Overall, these tools dramatically improved the technical work of the project.

\chapter{Simulation chain} \label{cha:Simulation_chain}

\epigraph{\textquotedblleft \textit{Divide et impera}\textquotedblright, \\ \textquotedblleft
Divide and conquer\textquotedblright}{Philip II of Macedon}

At first glance, there is not clear why it is necessary to use three programs at the
simulation stage instead of just one. The answer is quite simple: each one of those
programs has been developed to run a specific task in the simulation process, and 
therefore, each one has been optimized to do it as accurate and fast as possible. 
While MadGraph and Pythia are responsible for the simulation of high energy collision's 
Physics, Delphes takes the final state particles produces by the former programs, and
determines which would be the corresponding response of a detector. This scheme is
useful as it maintains the detector apart from the main calculations of the simulation.
Additionally, it makes changing the experiment parameters as simple as modifying
Delphes execution specifications.

As presented before, MadGraph and Pythia handle the Physics of the collision. There
are again more than a single program for this task, and now the reason lies in the
limits of the theoretical models. At the very first moment of the collision when
the Energy Density of the System is high enough, perturbative Quantum Chromo-Dynamics
(pQCD), Quantum Electro-Dynamics (QED) and ElectroWeak Theory are the most accurate models
known so far. MadGraph, and specifically MadEvent, use them to calculate the transverse
sections of a particular channel defined by the user. From this calculation and Monte 
Carlo models, it randomly establishes the kinematic variables of the resulting particles
of the collision.

Once the energy density of the collision has been reduced significantly, the models used
by MadGraph are not valid, and then Pythia appears in the scene. The particles resulting
from MadGraph are taken by Pythia, which makes the evolution to a multi-hadronic final
state ~\cite{Sjostrand:2014zea}. The task run by Pythia involves the usage of Monte
Carlo techniques to simulate hadronization, decays and showers. Finally, the particles
obtained at the end of the Pythia simulation are the inputs of the Delphes simulation.

Although the usage of several programs for the simulation means better results, it also
implies the challenge of connecting them. This task has already done inside the MadGraph
package, which connects MadEvent + Pythia 6 + Delphes / PGS\footnote{\textit{Pretty 
Good Simulation}, PGS, is another program for detector simulation}. However, the version
of Pythia included there (6th) is old and does not offer the possibility of controlling 
ISR emissions as the last one (8th) does. Because ISR emission was the main focus of the 
project, it was necessary to use Pythia 8 instead of Pythia 6 and therefore to develop
the integration of MadGraph 5.2, Pythia 8.2 and Delphes 3.2.

Throughout this chapter, the codes and scripts written to achieve the simulation will
be explained. One section is devoted to each program and another one presents the
script that connects the three programs. Finally, the last section of this chapter
present the procedure known as Matching between MadGraph and Pythia, which ensures that
the Physics calculations made by each program correspond to the Energy scale that
each one should handle.

\section{Usage of MadGraph 5.2} \label{sec:MadGraph}

The most basic procedure to simulate collision events using MadGraph is by means of its
executable program. Follow the next steps to run a set of simulations of the channel
$ p\ p\ \to t\ \tilde{t} $. It is important that MadGraph has been correctly installed
\footnote{A full set of instructions to install MadGraph and other High Energy Physics
programs can be found at \url{http://goo.gl/vigBdj}}.

\begin{enumerate}
\item In the folder where MadGraph has been installed, type:  
\\ \texttt{./bin/mg5\_aMC}
\item Once MadGraph has been initialized, import the Standard Model parameters:
\\ \texttt{import model sm}
\item Generate the event $ p\ p\ \to t\ \tilde{t} $:
\\ \texttt{generate p p > t t$ \sim $}
\item Create an output folder where all the simulation files will be saved, in this case
test\_t\_tbar:
\\ \texttt{output test\_t\_tbar} 
\item Launch the Feynman diagrams production:
\\ \texttt{launch -m}
\\ and select the number of cores you want to use for the simulation
\item Turn off Pythia and other programs\footnote{This project uses the last version 
of Pythia (8.2) instead of the sixth version that uses MadGraph}. You can switch 
off and on by typing the number before the program (type 1 to toggle pythia, for instance).
Then, press enter.
\item Modify the \texttt{run\_card.dat} file by typing 2. Write \texttt{:32} and press
enter to go to line 32, then type \texttt{i} and press enter to modify the file. Change
the number of events from 10000 to 1000. Press \texttt{Esc} and write \texttt{:wq} to
write and quit.
\item Press enter to run the simulation

\end{enumerate}

Although simple, the latter approach is not the best as it requires the user interaction
several times to configure the simulation, which is not desirable when more than a single 
simulation will be performed. In such situations, all the configuration parameters
can be defined trough an input file. For the previous example, the input file would be:

\noindent \texttt{import model sm
\\generate p p > t t\~
\\output test\_t\_tbar -f
\\launch -m
\\2
\\pythia=OFF
\\Template/LO/Cards/run\_card.dat
\\models/sm\_v4/param\_card.dat}

\noindent where 2 corresponds to the number of cores used in the simulation, 
\texttt{run\_card.dat} is the default file of MadGraph and \texttt{param\_card.dat} 
contains the Standard Model parameters and values. Here, these two files correspond
to the default ones that MadGraph provide. In order to use another set of 
configuration parameters, the files should be copied to another location
and modified according to desired simulation conditions.

The input file may be saved as \texttt{mg5\_input.mg5} and the simulation can be
executed as:

\noindent \texttt{./bin/mg5\_aMC -f mg5\_input.mg5} \footnote{Observe that it is
supposed that \texttt{mg5\_input.mg5} is localed at the MadGraph folder and that
the command is run from the same directory. If not, the execution instruction and
the input file should contain the full path accordingly.}

As a result of the simulation by MadGraph, the output folder contains several 
folders with all the information related to the simulation. The folder 
\texttt{Cards} for instance, contains some parameter cards used in the simulation,
while the folder \texttt{HTML}, and specially the file \texttt{info.html} present
the Feynman diagrams created by MadGraph. The events resulting from the simulation
are found in the folder \texttt{Events/run\_01} in the form of two files: a root 
file called \texttt{unweighted\_events.root} and a compressed Les Houches Event file
with name \texttt{unweighted\_events.lhe}.

\section{Usage of Pythia 8.2} \label{sec:Pythia8}

The simulation carried out by MadGraph is now passed to Pythia, which takes the
file \texttt{unweighted\_events.lhe} as input. For this step, a C++ code was written
based on the examples provided by Pythia developers and the specific requirements
of this project. In the following paragraphs, this code will be explained taking into
account the relevant issues for this project. A complete documentation can be found at
~\cite{Sjostrand:2006za}.

\subsection{The code}\label{sub:Pythia_code}

The code is called \texttt{hadronization2.cc} and was written in C++:

\lstinputlisting[language=C++]{source_filename.py}



About the program, three important
points should be highlighted:

\begin{itemize}
\item The code can be compiled using the \texttt{Makefile} available at the folder
examples. It is necessary to have installed Pythia including a HepMC package 
\footnote{Again, information to install Pythia 8.2 and HepMC can be found at
\url{http://goo.gl/vigBdj}}. Additionally, the \texttt{Makefile} 
\end{itemize}







\bibliographystyle{unsrt}

\bibliography{My_Bibliography_report}
	

\end{document}
